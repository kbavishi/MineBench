/*
  File autogenerated by gengetopt version 2.13.1
  generated with the following command:
  /usr/users/privmane/code/gengetopt-2.13.1/src/gengetopt -idistanceBasedSeqs2TreeSA.ggo -FdistanceBasedSeqs2TreeSA_cmdline 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "distanceBasedSeqs2TreeSA_cmdline.h"

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error);


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->pD_given = 0 ;
  args_info->jc_given = 0 ;
  args_info->homogeneousRates_given = 0 ;
  args_info->pairwiseGamma_given = 0 ;
  args_info->commonAlpha_given = 0 ;
  args_info->rate4site_given = 0 ;
  args_info->posterior_given = 0 ;
  args_info->bootstrap_given = 0 ;
  args_info->dontOptimizeBranchLengths_given = 0 ;
  args_info->epsilonLikelihoodImprovement_given = 0 ;
  args_info->epsilonLikelihoodImprovement4alphaOptimiz_given = 0 ;
  args_info->epsilonLikelihoodImprovement4BBL_given = 0 ;
  args_info->sequence_given = 0 ;
  args_info->tree_given = 0 ;
  args_info->constraint_given = 0 ;
  args_info->outputfile_given = 0 ;
  args_info->treeoutputfile_given = 0 ;
  args_info->gaps_given = 0 ;
  args_info->seed_given = 0 ;
  args_info->alphabet_given = 0 ;
  args_info->ratio_given = 0 ;
  args_info->ACGprob_given = 0 ;
  args_info->inputRate_given = 0 ;
  args_info->homogeneous_given = 0 ;
  args_info->alpha_given = 0 ;
  args_info->optimizeAlpha_given = 0 ;
  args_info->categories_given = 0 ;
  args_info->laguerre_given = 0 ;
  args_info->day_given = 0 ;
  args_info->jtt_given = 0 ;
  args_info->rev_given = 0 ;
  args_info->wag_given = 0 ;
  args_info->cprev_given = 0 ;
  args_info->nucjc_given = 0 ;
  args_info->aaJC_given = 0 ;
  args_info->k2p_given = 0 ;
  args_info->hky_given = 0 ;
  args_info->modelfile_given = 0 ;
  args_info->verbose_given = 0 ;
  args_info->Logfile_given = 0 ;
  args_info->Methods_group_counter = 0 ;
  args_info->Model_group_counter = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  args_info->dontOptimizeBranchLengths_flag = 0;
  args_info->epsilonLikelihoodImprovement_arg = 0.01 ;
  args_info->epsilonLikelihoodImprovement4alphaOptimiz_arg = 0.01 ;
  args_info->epsilonLikelihoodImprovement4BBL_arg = 0.01 ;
  args_info->sequence_arg = gengetopt_strdup ("-");
  args_info->tree_arg = NULL;
  args_info->constraint_arg = NULL;
  args_info->outputfile_arg = gengetopt_strdup ("-");
  args_info->treeoutputfile_arg = gengetopt_strdup ("-");
  args_info->gaps_flag = 0;
  args_info->alphabet_arg = 20 ;
  args_info->ratio_arg = 2.0 ;
  args_info->ACGprob_arg = gengetopt_strdup ("0.25,0.25,0.25");
  args_info->inputRate_arg = 1.0 ;
  args_info->homogeneous_flag = 0;
  args_info->optimizeAlpha_flag = 0;
  args_info->categories_arg = 8 ;
  args_info->laguerre_flag = 0;
  args_info->modelfile_arg = NULL;
  args_info->verbose_arg = 1 ;
  args_info->Logfile_arg = gengetopt_strdup ("-");
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n", CMDLINE_PARSER_PACKAGE, CMDLINE_PARSER_VERSION);
}

void
cmdline_parser_print_help (void)
{
  cmdline_parser_print_version ();
  printf("\n%s\n", "Distance-based phylogeny reconstrustion with any distance measure and any tree \nreconstruction method. May be executed iteratively while optimizing some side \ninformation about the tree\nComments:\n1. Iterative methods can be given an initial starting tree that is given in the \n--tree parameter. If --alpha is given than the fixed tree topology and branch \nlengths will be used for the calculation of the side information for the first \niteration. Else, the first iteration will start with optimization of the branch \nlengths and the side information for the given topology.\n2. Bootstrapping may be done for a tree that is given in the --tree parameter. \nThis will automatically turn on the --bootstrapOnly flag. Alpha must also be \ngiven for iterative methods that use gamma-ASRV.");
  printf("\nUsage: Distance-based phylogeny reconstrustion [OPTIONS]...\n\n");
  printf("%s\n","  -h, --help                    Print help and exit");
  printf("%s\n","  -V, --version                 Print version and exit");
  printf("%s\n","\n Group: Methods\n  pairwise distance estimation method");
  printf("%s\n","\nPairwise distance estimation methods:");
  printf("%s\n","      --pD                      p-Distance");
  printf("%s\n","      --jc                      Jukes and Kantor distance");
  printf("%s\n","      --homogeneousRates        homogeneous rates MLE distance");
  printf("%s\n","      --pairwiseGamma           Gamma-ASRV with alpha optimized for each pair. \n                                  (must give either --alpha or --optimizeAlpha)");
  printf("%s\n","\nIterative distance-based tree reconstruction, with distance estimation methods \nthat utilize side information from the tree of the previous iteration:");
  printf("%s\n","      --commonAlpha             Iterative tree reconstruction; the side \n                                  information being the alpha parameter. (must \n                                  use --optimizeAlpha; may give an initial \n                                  alpha value in --alpha)");
  printf("%s\n","      --rate4site               Iterative tree reconstruction; the side \n                                  information being the ML rate for each site");
  printf("%s\n","      --posterior               Iterative tree reconstruction; the side \n                                  information being the posterior probabilities \n                                  of the rates at each site. (must use \n                                  --optimizeAlpha; may give an initial alpha \n                                  value in --alpha)");
  printf("%s\n","  -b, --bootstrap=INT           Do a given number of bootstrap iterations. To \n                                  bootstrap a known tree give it in the -tree \n                                  parameter");
  printf("%s\n","  -B, --dontOptimizeBranchLengths\n                                Don't optimize branch lengths  (default=off)");
  printf("%s\n","  -E, --epsilonLikelihoodImprovement=FLOAT\n                                The threshold for optimization of likelihood of \n                                  the tree  (default=`0.01')");
  printf("%s\n","      --epsilonLikelihoodImprovement4alphaOptimiz=FLOAT\n                                The threshold for optimization of likelihood of \n                                  the tree  (default=`0.01')");
  printf("%s\n","      --epsilonLikelihoodImprovement4BBL=FLOAT\n                                The threshold for optimization of likelihood of \n                                  the tree  (default=`0.01')");
  printf("%s\n","\nBasic Options:");
  printf("%s\n","  -s, --sequence=FILENAME       Sequence file name  (default=`-')");
  printf("%s\n","  -t, --tree=FILENAME           Tree file name");
  printf("%s\n","  -c, --constraint=FILENAME     Constraint Tree file name");
  printf("%s\n","  -o, --outputfile=FILENAME     Output file  (default=`-')");
  printf("%s\n","  -T, --treeoutputfile=FILENAME Tree output file  (default=`-')");
  printf("%s\n","  -g, --gaps                    Remove positions with gaps  (default=off)");
  printf("%s\n","  -r, --seed=LONG               Seed random number generator");
  printf("%s\n","\nModel Options:");
  printf("%s\n","  -a, --alphabet=4|20|61|64     Alphabet Size  (default=`20')");
  printf("%s\n","  -z, --ratio=FLOAT             Transition/Transversion ratio  (default=`2.0')");
  printf("%s\n","  -p, --ACGprob=A,C,G           User input nucleotide frequencies. String \n                                  separated list for A,C,G  \n                                  (default=`0.25,0.25,0.25')");
  printf("%s\n","      --inputRate=FLOAT         Set External globalRate  (default=`1.0')");
  printf("%s\n","\nAmong Site Rate Variation (ASRV):");
  printf("%s\n","  -H, --homogeneous             Don't use Gamma ASRV  (default=off)");
  printf("%s\n","  -A, --alpha=Alpha             Set alpha for Gamma ASRV");
  printf("%s\n","  -O, --optimizeAlpha           Optimize alpha for Gamma ASRV  (default=off)");
  printf("%s\n","  -C, --categories=INT          Number of categories to use with descrete Gamma \n                                  ASRV  (default=`8')");
  printf("%s\n","      --laguerre                Use Laguerre approximation of Gamma - CURRENTLY \n                                  NOT IMPLIMENTED  (default=off)");
  printf("%s\n","\n Group: Model\n  Model type");
  printf("%s\n","      --day                     Use 'day' model");
  printf("%s\n","      --jtt                     Use 'jtt' model (default)");
  printf("%s\n","      --rev                     Use 'rev' model");
  printf("%s\n","      --wag                     Use 'wag' model");
  printf("%s\n","      --cprev                   Use 'cprev' model");
  printf("%s\n","      --nucjc                   Use nucleic acid JC model");
  printf("%s\n","      --aaJC                    Use amino acid JC model");
  printf("%s\n","      --k2p                     Use 'k2p' model");
  printf("%s\n","      --hky                     Use 'k2p' model");
  printf("%s\n","      --modelfile=NAME          Use user input file as model");
  printf("%s\n","\nLog Options:");
  printf("%s\n","  -v, --verbose=INT             Log report level (verbose)  (default=`1')");
  printf("%s\n","  -l, --Logfile=FILENAME        Log output file name  (default=`-')");
  
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  
  if (args_info->sequence_arg)
    {
      free (args_info->sequence_arg); /* free previous argument */
      args_info->sequence_arg = 0;
    }
  if (args_info->tree_arg)
    {
      free (args_info->tree_arg); /* free previous argument */
      args_info->tree_arg = 0;
    }
  if (args_info->constraint_arg)
    {
      free (args_info->constraint_arg); /* free previous argument */
      args_info->constraint_arg = 0;
    }
  if (args_info->outputfile_arg)
    {
      free (args_info->outputfile_arg); /* free previous argument */
      args_info->outputfile_arg = 0;
    }
  if (args_info->treeoutputfile_arg)
    {
      free (args_info->treeoutputfile_arg); /* free previous argument */
      args_info->treeoutputfile_arg = 0;
    }
  if (args_info->ACGprob_arg)
    {
      free (args_info->ACGprob_arg); /* free previous argument */
      args_info->ACGprob_arg = 0;
    }
  if (args_info->modelfile_arg)
    {
      free (args_info->modelfile_arg); /* free previous argument */
      args_info->modelfile_arg = 0;
    }
  if (args_info->Logfile_arg)
    {
      free (args_info->Logfile_arg); /* free previous argument */
      args_info->Logfile_arg = 0;
    }
  
  clear_given (args_info);
}

/* gengetopt_strdup() */
/* strdup.c replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static void
reset_group_Methods(struct gengetopt_args_info *args_info);

static void
reset_group_Methods(struct gengetopt_args_info *args_info)
{
  if (! args_info->Methods_group_counter)
    return;
  
  args_info->pD_given = 0 ;
  args_info->jc_given = 0 ;
  args_info->homogeneousRates_given = 0 ;
  args_info->pairwiseGamma_given = 0 ;
  args_info->commonAlpha_given = 0 ;
  args_info->rate4site_given = 0 ;
  args_info->posterior_given = 0 ;

  args_info->Methods_group_counter = 0;
}

static void
reset_group_Model(struct gengetopt_args_info *args_info);

static void
reset_group_Model(struct gengetopt_args_info *args_info)
{
  if (! args_info->Model_group_counter)
    return;
  
  args_info->day_given = 0 ;
  args_info->jtt_given = 0 ;
  args_info->rev_given = 0 ;
  args_info->wag_given = 0 ;
  args_info->cprev_given = 0 ;
  args_info->nucjc_given = 0 ;
  args_info->aaJC_given = 0 ;
  args_info->k2p_given = 0 ;
  args_info->hky_given = 0 ;

  args_info->Model_group_counter = 0;
}

int
cmdline_parser (int argc, char * const *argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser2 (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;

  result = cmdline_parser_internal (argc, argv, args_info, override, initialize, check_required, NULL);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  return EXIT_SUCCESS;
}

int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 1;
  opterr = 1;
  optopt = '?';

  while (1)
    {
      int option_index = 0;
      char *stop_char;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "pD",	0, NULL, 0 },
        { "jc",	0, NULL, 0 },
        { "homogeneousRates",	0, NULL, 0 },
        { "pairwiseGamma",	0, NULL, 0 },
        { "commonAlpha",	0, NULL, 0 },
        { "rate4site",	0, NULL, 0 },
        { "posterior",	0, NULL, 0 },
        { "bootstrap",	1, NULL, 'b' },
        { "dontOptimizeBranchLengths",	0, NULL, 'B' },
        { "epsilonLikelihoodImprovement",	1, NULL, 'E' },
        { "epsilonLikelihoodImprovement4alphaOptimiz",	1, NULL, 0 },
        { "epsilonLikelihoodImprovement4BBL",	1, NULL, 0 },
        { "sequence",	1, NULL, 's' },
        { "tree",	1, NULL, 't' },
        { "constraint",	1, NULL, 'c' },
        { "outputfile",	1, NULL, 'o' },
        { "treeoutputfile",	1, NULL, 'T' },
        { "gaps",	0, NULL, 'g' },
        { "seed",	1, NULL, 'r' },
        { "alphabet",	1, NULL, 'a' },
        { "ratio",	1, NULL, 'z' },
        { "ACGprob",	1, NULL, 'p' },
        { "inputRate",	1, NULL, 0 },
        { "homogeneous",	0, NULL, 'H' },
        { "alpha",	1, NULL, 'A' },
        { "optimizeAlpha",	0, NULL, 'O' },
        { "categories",	1, NULL, 'C' },
        { "laguerre",	0, NULL, 0 },
        { "day",	0, NULL, 0 },
        { "jtt",	0, NULL, 0 },
        { "rev",	0, NULL, 0 },
        { "wag",	0, NULL, 0 },
        { "cprev",	0, NULL, 0 },
        { "nucjc",	0, NULL, 0 },
        { "aaJC",	0, NULL, 0 },
        { "k2p",	0, NULL, 0 },
        { "hky",	0, NULL, 0 },
        { "modelfile",	1, NULL, 0 },
        { "verbose",	1, NULL, 'v' },
        { "Logfile",	1, NULL, 'l' },
        { NULL,	0, NULL, 0 }
      };

      stop_char = 0;
      c = getopt_long (argc, argv, "hVb:BE:s:t:c:o:T:gr:a:z:p:HA:OC:v:l:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'b':	/* Do a given number of bootstrap iterations. To bootstrap a known tree give it in the -tree parameter.  */
          if (local_args_info.bootstrap_given)
            {
              fprintf (stderr, "%s: `--bootstrap' (`-b') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->bootstrap_given && ! override)
            continue;
          local_args_info.bootstrap_given = 1;
          args_info->bootstrap_given = 1;
          args_info->bootstrap_arg = strtol (optarg,&stop_char,0);
          break;

        case 'B':	/* Don't optimize branch lengths.  */
          if (local_args_info.dontOptimizeBranchLengths_given)
            {
              fprintf (stderr, "%s: `--dontOptimizeBranchLengths' (`-B') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->dontOptimizeBranchLengths_given && ! override)
            continue;
          local_args_info.dontOptimizeBranchLengths_given = 1;
          args_info->dontOptimizeBranchLengths_given = 1;
          args_info->dontOptimizeBranchLengths_flag = !(args_info->dontOptimizeBranchLengths_flag);
          break;

        case 'E':	/* The threshold for optimization of likelihood of the tree.  */
          if (local_args_info.epsilonLikelihoodImprovement_given)
            {
              fprintf (stderr, "%s: `--epsilonLikelihoodImprovement' (`-E') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->epsilonLikelihoodImprovement_given && ! override)
            continue;
          local_args_info.epsilonLikelihoodImprovement_given = 1;
          args_info->epsilonLikelihoodImprovement_given = 1;
          args_info->epsilonLikelihoodImprovement_arg = (float)strtod (optarg, NULL);
          break;

        case 's':	/* Sequence file name.  */
          if (local_args_info.sequence_given)
            {
              fprintf (stderr, "%s: `--sequence' (`-s') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->sequence_given && ! override)
            continue;
          local_args_info.sequence_given = 1;
          args_info->sequence_given = 1;
          if (args_info->sequence_arg)
            free (args_info->sequence_arg); /* free previous string */
          args_info->sequence_arg = gengetopt_strdup (optarg);
          break;

        case 't':	/* Tree file name.  */
          if (local_args_info.tree_given)
            {
              fprintf (stderr, "%s: `--tree' (`-t') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->tree_given && ! override)
            continue;
          local_args_info.tree_given = 1;
          args_info->tree_given = 1;
          if (args_info->tree_arg)
            free (args_info->tree_arg); /* free previous string */
          args_info->tree_arg = gengetopt_strdup (optarg);
          break;

        case 'c':	/* Constraint Tree file name.  */
          if (local_args_info.constraint_given)
            {
              fprintf (stderr, "%s: `--constraint' (`-c') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->constraint_given && ! override)
            continue;
          local_args_info.constraint_given = 1;
          args_info->constraint_given = 1;
          if (args_info->constraint_arg)
            free (args_info->constraint_arg); /* free previous string */
          args_info->constraint_arg = gengetopt_strdup (optarg);
          break;

        case 'o':	/* Output file.  */
          if (local_args_info.outputfile_given)
            {
              fprintf (stderr, "%s: `--outputfile' (`-o') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->outputfile_given && ! override)
            continue;
          local_args_info.outputfile_given = 1;
          args_info->outputfile_given = 1;
          if (args_info->outputfile_arg)
            free (args_info->outputfile_arg); /* free previous string */
          args_info->outputfile_arg = gengetopt_strdup (optarg);
          break;

        case 'T':	/* Tree output file.  */
          if (local_args_info.treeoutputfile_given)
            {
              fprintf (stderr, "%s: `--treeoutputfile' (`-T') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->treeoutputfile_given && ! override)
            continue;
          local_args_info.treeoutputfile_given = 1;
          args_info->treeoutputfile_given = 1;
          if (args_info->treeoutputfile_arg)
            free (args_info->treeoutputfile_arg); /* free previous string */
          args_info->treeoutputfile_arg = gengetopt_strdup (optarg);
          break;

        case 'g':	/* Remove positions with gaps.  */
          if (local_args_info.gaps_given)
            {
              fprintf (stderr, "%s: `--gaps' (`-g') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->gaps_given && ! override)
            continue;
          local_args_info.gaps_given = 1;
          args_info->gaps_given = 1;
          args_info->gaps_flag = !(args_info->gaps_flag);
          break;

        case 'r':	/* Seed random number generator.  */
          if (local_args_info.seed_given)
            {
              fprintf (stderr, "%s: `--seed' (`-r') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->seed_given && ! override)
            continue;
          local_args_info.seed_given = 1;
          args_info->seed_given = 1;
          args_info->seed_arg = strtol (optarg,&stop_char,0);
          break;

        case 'a':	/* Alphabet Size.  */
          if (local_args_info.alphabet_given)
            {
              fprintf (stderr, "%s: `--alphabet' (`-a') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->alphabet_given && ! override)
            continue;
          local_args_info.alphabet_given = 1;
          args_info->alphabet_given = 1;
          args_info->alphabet_arg = strtol (optarg,&stop_char,0);
          break;

        case 'z':	/* Transition/Transversion ratio.  */
          if (local_args_info.ratio_given)
            {
              fprintf (stderr, "%s: `--ratio' (`-z') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->ratio_given && ! override)
            continue;
          local_args_info.ratio_given = 1;
          args_info->ratio_given = 1;
          args_info->ratio_arg = (float)strtod (optarg, NULL);
          break;

        case 'p':	/* User input nucleotide frequencies. String separated list for A,C,G.  */
          if (local_args_info.ACGprob_given)
            {
              fprintf (stderr, "%s: `--ACGprob' (`-p') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->ACGprob_given && ! override)
            continue;
          local_args_info.ACGprob_given = 1;
          args_info->ACGprob_given = 1;
          if (args_info->ACGprob_arg)
            free (args_info->ACGprob_arg); /* free previous string */
          args_info->ACGprob_arg = gengetopt_strdup (optarg);
          break;

        case 'H':	/* Don't use Gamma ASRV.  */
          if (local_args_info.homogeneous_given)
            {
              fprintf (stderr, "%s: `--homogeneous' (`-H') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->homogeneous_given && ! override)
            continue;
          local_args_info.homogeneous_given = 1;
          args_info->homogeneous_given = 1;
          args_info->homogeneous_flag = !(args_info->homogeneous_flag);
          break;

        case 'A':	/* Set alpha for Gamma ASRV.  */
          if (local_args_info.alpha_given)
            {
              fprintf (stderr, "%s: `--alpha' (`-A') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->alpha_given && ! override)
            continue;
          local_args_info.alpha_given = 1;
          args_info->alpha_given = 1;
          args_info->alpha_arg = (float)strtod (optarg, NULL);
          break;

        case 'O':	/* Optimize alpha for Gamma ASRV.  */
          if (local_args_info.optimizeAlpha_given)
            {
              fprintf (stderr, "%s: `--optimizeAlpha' (`-O') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->optimizeAlpha_given && ! override)
            continue;
          local_args_info.optimizeAlpha_given = 1;
          args_info->optimizeAlpha_given = 1;
          args_info->optimizeAlpha_flag = !(args_info->optimizeAlpha_flag);
          break;

        case 'C':	/* Number of categories to use with descrete Gamma ASRV.  */
          if (local_args_info.categories_given)
            {
              fprintf (stderr, "%s: `--categories' (`-C') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->categories_given && ! override)
            continue;
          local_args_info.categories_given = 1;
          args_info->categories_given = 1;
          args_info->categories_arg = strtol (optarg,&stop_char,0);
          break;

        case 'v':	/* Log report level (verbose).  */
          if (local_args_info.verbose_given)
            {
              fprintf (stderr, "%s: `--verbose' (`-v') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->verbose_given && ! override)
            continue;
          local_args_info.verbose_given = 1;
          args_info->verbose_given = 1;
          args_info->verbose_arg = strtol (optarg,&stop_char,0);
          break;

        case 'l':	/* Log output file name.  */
          if (local_args_info.Logfile_given)
            {
              fprintf (stderr, "%s: `--Logfile' (`-l') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->Logfile_given && ! override)
            continue;
          local_args_info.Logfile_given = 1;
          args_info->Logfile_given = 1;
          if (args_info->Logfile_arg)
            free (args_info->Logfile_arg); /* free previous string */
          args_info->Logfile_arg = gengetopt_strdup (optarg);
          break;


        case 0:	/* Long option with no short option */
          /* p-Distance.  */
          if (strcmp (long_options[option_index].name, "pD") == 0)
          {
            if (local_args_info.pD_given)
              {
                fprintf (stderr, "%s: `--pD' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->pD_given && ! override)
              continue;
            local_args_info.pD_given = 1;
            args_info->pD_given = 1;
            if (args_info->Methods_group_counter && override)
              reset_group_Methods (args_info);
            args_info->Methods_group_counter += 1;
            break;
          }
          /* Jukes and Kantor distance.  */
          else if (strcmp (long_options[option_index].name, "jc") == 0)
          {
            if (local_args_info.jc_given)
              {
                fprintf (stderr, "%s: `--jc' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->jc_given && ! override)
              continue;
            local_args_info.jc_given = 1;
            args_info->jc_given = 1;
            if (args_info->Methods_group_counter && override)
              reset_group_Methods (args_info);
            args_info->Methods_group_counter += 1;
            break;
          }
          /* homogeneous rates MLE distance.  */
          else if (strcmp (long_options[option_index].name, "homogeneousRates") == 0)
          {
            if (local_args_info.homogeneousRates_given)
              {
                fprintf (stderr, "%s: `--homogeneousRates' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->homogeneousRates_given && ! override)
              continue;
            local_args_info.homogeneousRates_given = 1;
            args_info->homogeneousRates_given = 1;
            if (args_info->Methods_group_counter && override)
              reset_group_Methods (args_info);
            args_info->Methods_group_counter += 1;
            break;
          }
          /* Gamma-ASRV with alpha optimized for each pair. (must give either --alpha or --optimizeAlpha).  */
          else if (strcmp (long_options[option_index].name, "pairwiseGamma") == 0)
          {
            if (local_args_info.pairwiseGamma_given)
              {
                fprintf (stderr, "%s: `--pairwiseGamma' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->pairwiseGamma_given && ! override)
              continue;
            local_args_info.pairwiseGamma_given = 1;
            args_info->pairwiseGamma_given = 1;
            if (args_info->Methods_group_counter && override)
              reset_group_Methods (args_info);
            args_info->Methods_group_counter += 1;
            break;
          }
          /* Iterative tree reconstruction; the side information being the alpha parameter. (must use --optimizeAlpha; may give an initial alpha value in --alpha).  */
          else if (strcmp (long_options[option_index].name, "commonAlpha") == 0)
          {
            if (local_args_info.commonAlpha_given)
              {
                fprintf (stderr, "%s: `--commonAlpha' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->commonAlpha_given && ! override)
              continue;
            local_args_info.commonAlpha_given = 1;
            args_info->commonAlpha_given = 1;
            if (args_info->Methods_group_counter && override)
              reset_group_Methods (args_info);
            args_info->Methods_group_counter += 1;
            break;
          }
          /* Iterative tree reconstruction; the side information being the ML rate for each site.  */
          else if (strcmp (long_options[option_index].name, "rate4site") == 0)
          {
            if (local_args_info.rate4site_given)
              {
                fprintf (stderr, "%s: `--rate4site' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->rate4site_given && ! override)
              continue;
            local_args_info.rate4site_given = 1;
            args_info->rate4site_given = 1;
            if (args_info->Methods_group_counter && override)
              reset_group_Methods (args_info);
            args_info->Methods_group_counter += 1;
            break;
          }
          /* Iterative tree reconstruction; the side information being the posterior probabilities of the rates at each site. (must use --optimizeAlpha; may give an initial alpha value in --alpha).  */
          else if (strcmp (long_options[option_index].name, "posterior") == 0)
          {
            if (local_args_info.posterior_given)
              {
                fprintf (stderr, "%s: `--posterior' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->posterior_given && ! override)
              continue;
            local_args_info.posterior_given = 1;
            args_info->posterior_given = 1;
            if (args_info->Methods_group_counter && override)
              reset_group_Methods (args_info);
            args_info->Methods_group_counter += 1;
            break;
          }
          /* The threshold for optimization of likelihood of the tree.  */
          else if (strcmp (long_options[option_index].name, "epsilonLikelihoodImprovement4alphaOptimiz") == 0)
          {
            if (local_args_info.epsilonLikelihoodImprovement4alphaOptimiz_given)
              {
                fprintf (stderr, "%s: `--epsilonLikelihoodImprovement4alphaOptimiz' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->epsilonLikelihoodImprovement4alphaOptimiz_given && ! override)
              continue;
            local_args_info.epsilonLikelihoodImprovement4alphaOptimiz_given = 1;
            args_info->epsilonLikelihoodImprovement4alphaOptimiz_given = 1;
            args_info->epsilonLikelihoodImprovement4alphaOptimiz_arg = (float)strtod (optarg, NULL);
          }
          /* The threshold for optimization of likelihood of the tree.  */
          else if (strcmp (long_options[option_index].name, "epsilonLikelihoodImprovement4BBL") == 0)
          {
            if (local_args_info.epsilonLikelihoodImprovement4BBL_given)
              {
                fprintf (stderr, "%s: `--epsilonLikelihoodImprovement4BBL' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->epsilonLikelihoodImprovement4BBL_given && ! override)
              continue;
            local_args_info.epsilonLikelihoodImprovement4BBL_given = 1;
            args_info->epsilonLikelihoodImprovement4BBL_given = 1;
            args_info->epsilonLikelihoodImprovement4BBL_arg = (float)strtod (optarg, NULL);
          }
          /* Set External globalRate.  */
          else if (strcmp (long_options[option_index].name, "inputRate") == 0)
          {
            if (local_args_info.inputRate_given)
              {
                fprintf (stderr, "%s: `--inputRate' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->inputRate_given && ! override)
              continue;
            local_args_info.inputRate_given = 1;
            args_info->inputRate_given = 1;
            args_info->inputRate_arg = (float)strtod (optarg, NULL);
          }
          /* Use Laguerre approximation of Gamma - CURRENTLY NOT IMPLIMENTED.  */
          else if (strcmp (long_options[option_index].name, "laguerre") == 0)
          {
            if (local_args_info.laguerre_given)
              {
                fprintf (stderr, "%s: `--laguerre' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->laguerre_given && ! override)
              continue;
            local_args_info.laguerre_given = 1;
            args_info->laguerre_given = 1;
            args_info->laguerre_flag = !(args_info->laguerre_flag);
          }
          /* Use 'day' model.  */
          else if (strcmp (long_options[option_index].name, "day") == 0)
          {
            if (local_args_info.day_given)
              {
                fprintf (stderr, "%s: `--day' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->day_given && ! override)
              continue;
            local_args_info.day_given = 1;
            args_info->day_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use 'jtt' model (default).  */
          else if (strcmp (long_options[option_index].name, "jtt") == 0)
          {
            if (local_args_info.jtt_given)
              {
                fprintf (stderr, "%s: `--jtt' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->jtt_given && ! override)
              continue;
            local_args_info.jtt_given = 1;
            args_info->jtt_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use 'rev' model.  */
          else if (strcmp (long_options[option_index].name, "rev") == 0)
          {
            if (local_args_info.rev_given)
              {
                fprintf (stderr, "%s: `--rev' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->rev_given && ! override)
              continue;
            local_args_info.rev_given = 1;
            args_info->rev_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use 'wag' model.  */
          else if (strcmp (long_options[option_index].name, "wag") == 0)
          {
            if (local_args_info.wag_given)
              {
                fprintf (stderr, "%s: `--wag' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->wag_given && ! override)
              continue;
            local_args_info.wag_given = 1;
            args_info->wag_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use 'cprev' model.  */
          else if (strcmp (long_options[option_index].name, "cprev") == 0)
          {
            if (local_args_info.cprev_given)
              {
                fprintf (stderr, "%s: `--cprev' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->cprev_given && ! override)
              continue;
            local_args_info.cprev_given = 1;
            args_info->cprev_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use nucleic acid JC model.  */
          else if (strcmp (long_options[option_index].name, "nucjc") == 0)
          {
            if (local_args_info.nucjc_given)
              {
                fprintf (stderr, "%s: `--nucjc' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->nucjc_given && ! override)
              continue;
            local_args_info.nucjc_given = 1;
            args_info->nucjc_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use amino acid JC model.  */
          else if (strcmp (long_options[option_index].name, "aaJC") == 0)
          {
            if (local_args_info.aaJC_given)
              {
                fprintf (stderr, "%s: `--aaJC' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->aaJC_given && ! override)
              continue;
            local_args_info.aaJC_given = 1;
            args_info->aaJC_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use 'k2p' model.  */
          else if (strcmp (long_options[option_index].name, "k2p") == 0)
          {
            if (local_args_info.k2p_given)
              {
                fprintf (stderr, "%s: `--k2p' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->k2p_given && ! override)
              continue;
            local_args_info.k2p_given = 1;
            args_info->k2p_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use 'k2p' model.  */
          else if (strcmp (long_options[option_index].name, "hky") == 0)
          {
            if (local_args_info.hky_given)
              {
                fprintf (stderr, "%s: `--hky' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->hky_given && ! override)
              continue;
            local_args_info.hky_given = 1;
            args_info->hky_given = 1;
            if (args_info->Model_group_counter && override)
              reset_group_Model (args_info);
            args_info->Model_group_counter += 1;
            break;
          }
          /* Use user input file as model.  */
          else if (strcmp (long_options[option_index].name, "modelfile") == 0)
          {
            if (local_args_info.modelfile_given)
              {
                fprintf (stderr, "%s: `--modelfile' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->modelfile_given && ! override)
              continue;
            local_args_info.modelfile_given = 1;
            args_info->modelfile_given = 1;
            if (args_info->modelfile_arg)
              free (args_info->modelfile_arg); /* free previous string */
            args_info->modelfile_arg = gengetopt_strdup (optarg);
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */

  if ( args_info->Methods_group_counter > 1)
    {
      fprintf (stderr, "%s: %d options of group Methods were given. At most one is required.%s\n", argv[0], args_info->Methods_group_counter, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if ( args_info->Model_group_counter > 1)
    {
      fprintf (stderr, "%s: %d options of group Model were given. At most one is required.%s\n", argv[0], args_info->Model_group_counter, (additional_error ? additional_error : ""));
      error = 1;
    }
  



  cmdline_parser_free (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  cmdline_parser_free (&local_args_info);
  return (EXIT_FAILURE);
}
